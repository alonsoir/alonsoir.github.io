# links
	
	https://github.com/PacktPublishing?utf8=✓&q=&type=&language=java

	https://learning.oreilly.com/live-training/courses/stream-processing-with-apache-spark/0636920360490/

	https://training.databricks.com/visualapi.pdf => pure gold!

	https://spark.apache.org/docs/latest/sql-programming-guide.html

	https://spark.apache.org/docs/latest/rdd-programming-guide.html

	https://es.wikipedia.org/wiki/Evaluación_perezosa

Install apache spark. 
	
	brew install apache-spark

	aironman@MacBook-Pro-de-Alonso ~> cd /usr/local/Cellar/apache-spark/2.4.4/libexec/conf/

	aironman@MacBook-Pro-de-Alonso /u/l/C/a/2/l/conf> mv log4j.properties.template log4j.properties

	change INFO error level to ERROR

	aironman@MacBook-Pro-de-Alonso /u/l/C/a/2/l/conf> spark-shell
	# how many lines has this file?
	scala> sc.textFile("testSpark.txt").count
	res0: Long = 1

Download this set of files. http://files.grouplens.org/datasets/movielens/ml-100k.zip

New scala project, new scala file...

build.sbt

	name := "spark-scala"

	version := "0.1"

	scalaVersion := "2.12.8"

	libraryDependencies += "org.apache.spark" %% "spark-core" % "2.4.5"

RatingsCounter.scala

	import org.apache.spark._
	import org.apache.spark.SparkContext._
	import org.apache.log4j._

	/** Count up how many of each star rating exists in the MovieLens 100K data set. */
	object RatingsCounter {
	 
	  /** Our main function where the action happens */
	  def main(args: Array[String]) {
	   
	    // Set the log level to only print errors
	    Logger.getLogger("org").setLevel(Level.ERROR)
	        
	    // Create a SparkContext using every core of the local machine, named RatingsCounter
	    val sc = new SparkContext("local[*]", "RatingsCounter")
	   
	    // Load up each line of the ratings data into an RDD
	    val lines = sc.textFile("../ml-100k/u.data")
	    
	    // Convert each line to a string, split it out by tabs, and extract the third field.
	    // (The file format is userID, movieID, rating, timestamp)
	    // UserId watch this movieId, gives it this rating at this timestamp
	    // 291	118	2	874833878
		// 308	1	4	887736532
		// 95	546	2	879196566
	    // ...
	    val ratings = lines.map(x => x.toString().split("\t")(2))
	    
	    // Count up how many times each value (rating) occurs
	    val results = ratings.countByValue()
	    
	    // Sort the resulting map of (rating, count) tuples
	    val sortedResults = results.toSeq.sortBy(_._1)
	    
	    // Print each result on its own line.
	    sortedResults.foreach(println)

	    /*
		/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/bin/java "-javaagent:/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar=54459:/Applications/IntelliJ IDEA CE.app/Contents/bin" -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/lib/tools.jar:/Users/aironman/gitProjects/spark-scala/target/scala-2.12/classes:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xml-apis/xml-apis/1.3.04/xml-apis-1.3.04.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/xerces/xercesImpl/2.9.1/xercesImpl-2.9.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/oro/oro/2.0.8/oro-2.0.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/xerial/snappy/snappy-java/1.1.7.3/snappy-java-1.1.7.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/tukaani/xz/1.5/xz-1.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/spark-project/spark/unused/1.0.0/unused-1.0.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-log4j12/1.7.16/slf4j-log4j12-1.7.16.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-api/1.7.16/slf4j-api-1.7.16.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jul-to-slf4j/1.7.16/jul-to-slf4j-1.7.16.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/slf4j/jcl-over-slf4j/1.7.16/jcl-over-slf4j-1.7.16.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-xml_2.12/1.0.6/scala-xml_2.12-1.0.6.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.12.8/scala-reflect-2.12.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.12.8/scala-library-2.12.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/roaringbitmap/shims/0.7.45/shims-0.7.45.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/roaringbitmap/RoaringBitmap/0.7.45/RoaringBitmap-0.7.45.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/objenesis/objenesis/2.5.1/objenesis-2.5.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/lz4/lz4-java/1.4.0/lz4-java-1.4.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-scalap_2.12/3.5.3/json4s-scalap_2.12-3.5.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-jackson_2.12/3.5.3/json4s-jackson_2.12-3.5.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-core_2.12/3.5.3/json4s-core_2.12-3.5.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/json4s/json4s-ast_2.12/3.5.3/json4s-ast_2.12-3.5.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/javassist/javassist/3.18.1-GA/javassist-3.18.1-GA.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/htrace/htrace-core/3.0.4/htrace-core-3.0.4.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/media/jersey-media-jaxb/2.22.2/jersey-media-jaxb-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/core/jersey-server/2.22.2/jersey-server-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/core/jersey-common/2.22.2/jersey-common-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/core/jersey-client/2.22.2/jersey-client-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/containers/jersey-container-servlet-core/2.22.2/jersey-container-servlet-core-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/containers/jersey-container-servlet/2.22.2/jersey-container-servlet-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/jersey/bundles/repackaged/jersey-guava/2.22.2/jersey-guava-2.22.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/external/javax.inject/2.4.0-b34/javax.inject-2.4.0-b34.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/external/aopalliance-repackaged/2.4.0-b34/aopalliance-repackaged-2.4.0-b34.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/osgi-resource-locator/1.0.1/osgi-resource-locator-1.0.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/hk2-utils/2.4.0-b34/hk2-utils-2.4.0-b34.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/hk2-locator/2.4.0-b34/hk2-locator-2.4.0-b34.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/glassfish/hk2/hk2-api/2.4.0-b34/hk2-api-2.4.0-b34.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/fusesource/leveldbjni/leveldbjni-all/1.8/leveldbjni-all-1.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/xbean/xbean-asm6-shaded/4.8/xbean-asm6-shaded-4.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-unsafe_2.12/2.4.5/spark-unsafe_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/2.4.5/spark-tags_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-network-shuffle_2.12/2.4.5/spark-network-shuffle_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-network-common_2.12/2.4.5/spark-network-common_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-launcher_2.12/2.4.5/spark-launcher_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-kvstore_2.12/2.4.5/spark-kvstore_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/spark/spark-core_2.12/2.4.5/spark-core_2.12-2.4.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/ivy/ivy/2.4.0/ivy-2.4.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.2.4/httpcore-4.2.4.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/httpcomponents/httpclient/4.2.5/httpclient-4.2.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-yarn-server-nodemanager/2.6.5/hadoop-yarn-server-nodemanager-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-yarn-server-common/2.6.5/hadoop-yarn-server-common-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-yarn-common/2.6.5/hadoop-yarn-common-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-yarn-client/2.6.5/hadoop-yarn-client-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-yarn-api/2.6.5/hadoop-yarn-api-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-mapreduce-client-shuffle/2.6.5/hadoop-mapreduce-client-shuffle-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-mapreduce-client-jobclient/2.6.5/hadoop-mapreduce-client-jobclient-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-mapreduce-client-core/2.6.5/hadoop-mapreduce-client-core-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-mapreduce-client-common/2.6.5/hadoop-mapreduce-client-common-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-mapreduce-client-app/2.6.5/hadoop-mapreduce-client-app-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-hdfs/2.6.5/hadoop-hdfs-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-common/2.6.5/hadoop-common-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-client/2.6.5/hadoop-client-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-auth/2.6.5/hadoop-auth-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/hadoop/hadoop-annotations/2.6.5/hadoop-annotations-2.6.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/curator/curator-recipes/2.6.0/curator-recipes-2.6.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/curator/curator-framework/2.6.0/curator-framework-2.6.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/curator/curator-client/2.6.0/curator-client-2.6.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-math3/3.4.1/commons-math3-3.4.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-crypto/1.0.0/commons-crypto-1.0.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-compress/1.8.1/commons-compress-1.8.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/avro/avro-mapred/1.8.2/avro-mapred-1.8.2-hadoop2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/avro/avro-ipc/1.8.2/avro-ipc-1.8.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/apache/avro/avro/1.8.2/avro-1.8.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/sf/py4j/py4j/0.10.7/py4j-0.10.7.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/net/razorvine/pyrolite/4.13/pyrolite-4.13.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/jline/jline/0.9.94/jline-0.9.94.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/ws/rs/javax.ws.rs-api/2.0.1/javax.ws.rs-api-2.0.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/validation/validation-api/1.1.0.Final/validation-api-1.1.0.Final.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/annotation/javax.annotation-api/1.2/javax.annotation-api-1.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/javax/activation/activation/1.1.1/activation-1.1.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/netty/netty-all/4.1.42.Final/netty-all-4.1.42.Final.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/netty/netty/3.9.9.Final/netty-3.9.9.Final.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/dropwizard/metrics/metrics-jvm/3.1.5/metrics-jvm-3.1.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/dropwizard/metrics/metrics-json/3.1.5/metrics-json-3.1.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/dropwizard/metrics/metrics-graphite/3.1.5/metrics-graphite-3.1.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/io/dropwizard/metrics/metrics-core/3.1.5/metrics-core-3.1.5.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-net/commons-net/3.1/commons-net-3.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-codec/commons-codec/1.9/commons-codec-1.9.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/twitter/chill_2.12/0.9.3/chill_2.12-0.9.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/twitter/chill-java/0.9.3/chill-java-0.9.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/thoughtworks/paranamer/paranamer/2.8/paranamer-2.8.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/ning/compress-lzf/1.0.3/compress-lzf-1.0.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/inject/guice/3.0/guice-3.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/guava/guava/16.0.1/guava-16.0.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/github/luben/zstd-jni/1.3.2-2/zstd-jni-1.3.2-2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-scala_2.12/2.6.7.1/jackson-module-scala_2.12-2.6.7.1.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/module/jackson-module-paranamer/2.7.9/jackson-module-paranamer-2.7.9.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.6.7.3/jackson-databind-2.6.7.3.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.6.7/jackson-core-2.6.7.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.6.7/jackson-annotations-2.6.7.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/esotericsoftware/minlog/1.3.0/minlog-1.3.0.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/esotericsoftware/kryo-shaded/4.0.2/kryo-shaded-4.0.2.jar:/Users/aironman/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/com/clearspring/analytics/stream/2.7.0/stream-2.7.0.jar com.sundogsoftware.spark.RatingsCounter
		Using Spark's default log4j profile: org/apache/spark/log4j-defaults.properties
		(1,6110)
		(2,11370)
		(3,27145)
		(4,34174)
		(5,21201)

		Process finished with exit code 0
	    */
	  }
	}

#id, name, age, num-friends
1,Alonso,42,15
2,Jose, 38, 150
3,Angel,42,2
4,Maria,38,1
5,Antonio, 39,0
...

def parseLine(line:String) = {
	val fields = line.split(",")
	val age = fields(2).toInt
	val num-friends = fields(3).toInt
	(age,num-friends)
}

val lines = sc.textFile("fakeFriends.csv")

val rdd = lines.map(parseLine)

42,15
38,150
42,2
38,1
39,0
...

val totalByAges = rdd.mapValues(x=>(x,1)).reduceByKey((x,y) => (x._1 + y._1,x._2 +y._2))
	
#rdd.mapValues(x=>(x,1))
(42,(15,1))
(38,(150,1))
(42,(2,1))
(38,(1,1))
(39,(0,1))

#=>reduceByKey applies to two values. (15,1),(150,1),(2,1),(1,1),(0,1) donde x._1 es el 15 , y._1 es el 2, x._2 es 1 y y._2 es 1 en las tuplas que tienen el mismo key
# en este caso, 42. (42,(15,1)) (42,(2,1))

#reduceByKey((x,y) => (x._1 + y._1,x._2 +y._2)) 
(42,(17,2))
(38,(151,2))
(39,(0,1)) # => se tiene de amigo a si mismo


import org.apache.spark._
import org.apache.spark.SparkContext._
import org.apache.log4j._

/** Compute the average number of friends by age in a social network. */
object FriendsByAge {
  
  /** A function that splits a line of input into (age, numFriends) tuples. */
  def parseLine(line: String) = {
      // Split by commas
      val fields = line.split(",")
      // Extract the age and numFriends fields, and convert to integers
      val age = fields(2).toInt
      val numFriends = fields(3).toInt
      // Create a tuple that is our result.
      (age, numFriends)
  }
  
  /** Our main function where the action happens */
  def main(args: Array[String]) {
   
    // Set the log level to only print errors
    Logger.getLogger("org").setLevel(Level.ERROR)
        
    // Create a SparkContext using every core of the local machine
    val sc = new SparkContext("local[*]", "FriendsByAge")
  
    // Load each line of the source data into an RDD
    val lines = sc.textFile("/Users/aironman/Downloads/SparkScala/fakefriends.csv")
    
    // Use our parseLines function to convert to (age, numFriends) tuples
    val rdd = lines.map(parseLine)
    
    // Lots going on here...
    // We are starting with an RDD of form (age, numFriends) where age is the KEY and numFriends is the VALUE
    // We use mapValues to convert each numFriends value to a tuple of (numFriends, 1)
    // Then we use reduceByKey to sum up the total numFriends and total instances for each age, by
    // adding together all the numFriends values and 1's respectively.
    val totalsByAge = rdd.mapValues(x => (x, 1)).reduceByKey( (x,y) => (x._1 + y._1, x._2 + y._2))
    
    /*
	scala> rdd.mapValues(x=>(x,1)).takeSample(false,100).foreach(println)
	(45,(455,1))
	(38,(380,1))
	(56,(371,1))
	(65,(208,1))
	(18,(418,1))
	(58,(348,1))
	(28,(311,1))
	(40,(220,1))
	(44,(353,1))
	(59,(284,1))
    ...
    (55,(284,1))
	(66,(383,1))
	(39,(106,1))
	(40,(254,1))
	(38,(203,1))
	(68,(293,1))
	(29,(173,1))
	(29,(128,1))
	(19,(272,1))
	(60,(246,1))
	(67,(153,1))
	(45,(340,1))
	(59,(284,1))
	(54,(72,1))
	(58,(174,1))
	(45,(147,1))
	(30,(184,1))
	(57,(229,1))
	(38,(2,1))
	(24,(492,1))
	(52,(77,1))
	(33,(294,1))
	(67,(149,1))
	(56,(313,1))
	(31,(340,1))
	(43,(428,1))
	(31,(172,1))
	(28,(34,1))
	(18,(326,1))
	(28,(304,1))
	(18,(24,1))
	...

	ala> rdd.mapValues(x=>(x,1)).reduceByKey((x,y) => (x._1 + y._1,x._2 + y._2)).takeSample(true,10).foreach(println)
	(60,(1419,7))
	(48,(2814,10))
	(40,(4264,17))
	(58,(1282,11))
	(52,(3747,11))
	(47,(2099,9))
	(34,(1473,6))
	(56,(1840,6))
	(46,(2908,13))
	(52,(3747,11))
	...

	Esto significa lo siguiente, los usuarios que tienen 60 años, son 7 y entre todos suman 1419 amigos, por ejemplo.
    */

    // So now we have tuples of (age, (totalFriends, totalInstances))
    // To compute the average we divide totalFriends / totalInstances for each age.
    val averagesByAge = totalsByAge.mapValues(x => x._1 / x._2)

    /*
	Por lo que, tenemos que los usuarios de 60 años, la media por edad es 1419/7
    */
    
    // Collect the results from the RDD (This kicks off computing the DAG and actually executes the job)
    val results = averagesByAge.collect()
    
    // Sort and print the final results.
    results.sorted.foreach(println)
  }
    
}

fakeFriends.csv

0,Will,33,385
1,Jean-Luc,26,2
2,Hugh,55,221
3,Deanna,40,465
4,Quark,68,21
5,Weyoun,59,318
6,Gowron,37,220
7,Will,54,307
...


scala> results.sorted.foreach(println)
(18,343)
(19,213)
(20,165)
(21,350)
(22,206)
(23,246)
(24,233)
(25,197)
(26,242)
(27,228)
(28,209)
(29,215)
(30,235)
(31,267)
(32,207)
(33,325)
(34,245)
(35,211)
(36,246)
(37,249)
(38,193)
(39,169)
(40,250)
(41,268)
(42,303)
(43,230)
(44,282)
(45,309)
(46,223)
(47,233)
(48,281)
(49,184)
(50,254)
(51,302)
(52,340)
(53,222)
(54,278)
(55,295)
(56,306)
(57,258)
(58,116)
(59,220)
(60,202)
(61,256)
(62,220)
(63,384)
(64,281)
(65,298)
(66,276)
(67,214)
(68,269)


Let say that i have this (python) code:

	df_source = spark_session.read.format('jdbc').....
	df_reference = sql_context.read.parquet('/path/to/reference.parquet')

	df_source_hashed = df_source.withColumn('hashkey', md5(concat_ws('', *df_source.columns))) \
	            .cache()

	df_inserts = df_source_hashed.join(df_reference, pk_list, how='left_anti') \
	                    .select(lit('Insert').alias('_action'), *df_source_hashed) \
	                    .dropDuplicates() \
	                    .cache()
	inserts_count = df_inserts.count()

	df_updates = df_source_hashed.alias('a').join(df_reference.alias('b'), pk_list, how="inner") \
	                        .select(lit('Update').alias('_action'), *df_source_hashed) \
	                        .where(col('a.hashkey') != col('b.hashkey')) \
	                        .dropDuplicates() \
	                        .cache()
	updates_count = df_updates.count()

	df_output = df_inserts.union(df_updates)

	df_output.repartition(1).write.format('parquet').mode('overwrite').save('/path/to/output.parquet')

¿How can i improve performance?

	1. Avoid unnecesary counts, if you can.
	2. Do

		df_output = df_inserts.union(df_updates).cache()

	then if you have to, do counts
	3. the repartition(1) should be replaced by coalesce(1). The former will shuffle all data, while the latter will read in the existing partitions and not shuffle them again.
	3. Repartitioning to a single partition is discouraged, unless you can guarantee the data fit into one worker's memory.
	4. You can compute Insert and Update in one go, so that you don't have to join with df_reference twice.

		df_actions = df_source_hashed.alias('a').join(df_reference.alias('b'), pk_list, how="left") \
		                             .withColumn('_action', when(col('b.hashkey').isNull, 'Insert').otherwise(col('a.hashkey') != col('b.hashkey'), 'Update')) \
		                             .select(col('_action'), *df_source_hashed) \
		                             .dropDuplicates() \
		                             .cache()

		Since df_actions is cached, you can count inserts and updates quickly with only that one join in df_actions:

			inserts_count = df_actions.where(col('_action') === 'Insert').count()
			updates_count = df_actions.where(col('_action') === 'Update').count()
		
		And you can get rid of the union:
			
			df_output = df_actions.where(col('_action').isNotNull)
		
		If you have to write that output to parquet anyway, then you can get the count quickly from the parquet file if it is partitioned by the _action column 
		(Spark then only looks into parquet's metadata to get the count, it does not read any row):
			
			df_output.coalesce(1).write.partitionBy('_action').format('parquet').mode('overwrite').save('/path/to/output.parquet')
			df_output = sql_context.read.parquet('/path/to/output.parquet')
			inserts_count = df_output.where(col('_action') === 'Insert').count()
			updates_count = df_output.where(col('_action') === 'Update').count()


Lets say i have a file (1800.csv) like this:

ITE00100554,18000101,TMAX,-75,,,E,
ITE00100554,18000101,TMIN,-148,,,E,
GM000010962,18000101,PRCP,0,,,E,
EZE00100082,18000101,TMAX,-86,,,E,
EZE00100082,18000101,TMIN,-135,,,E,
ITE00100554,18000102,TMAX,-60,,I,E,
ITE00100554,18000102,TMIN,-125,,,E,
...

def parseLine(line:String) ={
	val fields = line.split(",")
	val stationId = fields(0)
	val entryType = fields(2)
	val temperature = fields(3).toFloat * 0.1f *(9.0f / 5.0f) + 32f
	(stationId,entryType,temperature)
}

val lines = sc.textFile("/Users/aironman/gitProjects/alonsoir.github.io/SparkScala/1800.csv")

val parsedLines = lines.map(parseLine)

parsedLines.foreach(println)
...
(GM000010962,PRCP,37.76)
(EZE00100082,TMAX,64.399994)
(EZE00100082,TMIN,55.04)
(ITE00100554,TMAX,75.380005)
(ITE00100554,TMIN,65.3)
(GM000010962,PRCP,32.0)
(EZE00100082,TMAX,66.740005)
...


# parsedLines are tuples with stationId,entryType,temperature

val minTemps = parsedLines.filter(x=> x._2 == "TMIN")

minTemps.foreach(println)
...
(ITE00100554,TMIN,36.5)
(EZE00100082,TMIN,33.26)
(ITE00100554,TMIN,34.88)
(EZE00100082,TMIN,31.46)
(ITE00100554,TMIN,37.58)
(EZE00100082,TMIN,34.52)
(ITE00100554,TMIN,36.5)
(EZE00100082,TMIN,31.28)

val stationTemps = minTemps.map(x=>(x._1,x._3.toFloat))

stationTemps.foreach(printl)
...
(EZE00100082,56.66)
(ITE00100554,69.619995)
(EZE00100082,59.9)
(ITE00100554,70.34)
(EZE00100082,55.04)
(ITE00100554,65.3)

val minTempByStation = stationTemps.reduceByKey((x,y)=>min(x,y))

# here i have an error. scala> val minTempByStation = stationTemps.reduceByKey((x,y)=>min(x,y))
# <console>:25: error: overloaded method value min with alternatives:
#   (columnName: String)org.apache.spark.sql.Column <and>
#   (e: org.apache.spark.sql.Column)org.apache.spark.sql.Column
#  cannot be applied to (Float, Float)
#        val minTempByStation = stationTemps.reduceByKey((x,y)=>min(x,y))

#SOLVED, i had to import exact dependency. Personally i hate this kind of scala errors because it is not clear. It could tell me, maybe wrong dependency...
import scala.math.min
                                   ^
val results = minTempByStation.collect

for (result <- results.sorted) {
       val station = result._1
       val temp = result._2
       val formattedTemp = f"$temp%.2f F"
       println(s"$station minimum temperature: $formattedTemp") 
}

EZE00100082 minimum temperature: 16,52 F
ITE00100554 minimum temperature: 18,50 F



val maxTempByStation = stationTemps.reduceByKey((x,y)=>max(x,y))

val results = maxTempByStation.collect

for (result <- results.sorted){
	val stationId = result._1
	val temp = result._2
	val formatedTemp = f"$temp%.2f F"
	println(s"$station maximum temperature: $formattedTemp") 
}

EZE00100082 max temperature: 90,14 F
ITE00100554 max temperature: 90,14 F

#Having this file:
aironman@MacBook-Pro-de-Alonso ~> cat testSpark.txt
this is a text file

# counting lines from file...
scala> sc.textFile("/Users/aironman/testSpark.txt").map(line=>(line,1)).reduceByKey(_+_).foreach(println)
(this is a text file,1)

# typical word count sample
sc.textFile("/Users/aironman/testSpark.txt").flatMap(x=>x.split(" ")).map(line=>(line,1)).reduceByKey(_+_).foreach(println)
(a,1)
(this,1)
(is,1)
(text,1)
(file,1)


sc.textFile("/Users/aironman/testSpark.txt").flatMap(x=>x.split(" ")).map(line=>(line,1)).reduceByKey(_+_).collect.sorted.foreach(println)
(a,1)
(file,1)
(is,1)
(text,1)
(this,1

scala> sc.textFile("/Users/aironman/testSpark.txt").flatMap(x=>x.split(" ")).map(line=>(line,1)).reduceByKey(_+_).toDF.registerTempTable("TEMP")

# spark is spark_session

scala> spark.table("TEMP").show
20/02/24 16:51:18 WARN ObjectStore: Version information not found in metastore. hive.metastore.schema.verification is not enabled so recording the schema version 1.2.0
20/02/24 16:51:18 WARN ObjectStore: Failed to get database default, returning NoSuchObjectException
20/02/24 16:51:18 WARN ObjectStore: Failed to get database global_temp, returning NoSuchObjectException
+----+---+
|  _1| _2|
+----+---+
|this|  1|
|  is|  1|
|file|  1|
|   a|  1|
|text|  1|
+----+---+

# counting words from a book
val book = sc.textFile("/Users/aironman/Downloads/SparkScala/book.txt")
book: org.apache.spark.rdd.RDD[String] = /Users/aironman/Downloads/SparkScala/book.txt MapPartitionsRDD[118] at textFile at <console>:26

book.flatMap(word=>word.split(" ")).map(l=>(l,1)).reduceByKey(_+_).foreach(println)
(convince,2)
(raises,2)
(Let,1)
("Flexibility,1)
(salesperson.,1)
...

or


scala> book.flatMap(word=>word.split(" ")).countByValue.foreach(println)
(convince,2)
(raises,2)
(Let,1)
("Flexibility,1)
(salesperson.,1)
...

countByValue happens in every worker, reduceByKey happens in driver

https://stackoverflow.com/questions/52915466/when-to-use-countbyvalue-and-when-to-use-map-reducebykey/52915892

book.map(word=>(word,1)).sortByKey()

...
(If you really have found a millions-of-dollars-per-year opportunity and you can't protect it, it's probably a matter of time before a larger company will identify that same opportunity. In this case, you may be better off going down the riskier "growth business" path instead of a lifestyle business, with the objective of gaining traction in the marketplace before others do, and getting acquired by that larger company down the road. That's all a big gamble, however.,1)
(If you scroll down, more detailed information is available about the product� but above the fold, things have been kept as simple and visual as possible. A large video dominates the page, which auto-plays when loaded. It's designed to capture your attention before you click away.,1)
(If you sell products online, Google Analytics is a free, sophisticated tool that lets you track trends with your customers, and where those customers came from. Go get an account, and integrate it with your website and any other websites that sell your products on your behalf.,1)


scala> val wordCount= sc.textFile("/Users/aironman/Downloads/SparkScala/twitter.txt").flatMap(line=>line.split(" ")).map(word=>(word,1)).reduceByKey((x,y)=>x+y).map(x=>(x._2,x._1)).sortByKey().foreach(println)
(1,384953089-Kw81gqpF1eja3ch8Y9qXqUfm6X6ReCKUiHOvORlS)
(1,consumerSecret)
(1,HSQxluLbHezug8GgdPfX8zqYPkFPdfX20i42GJCGWGPuX)
(1,6Xchc9BczeXBqNr7foRO8mok7LP2SkqTTegjtPwgPEciEmbXp7)
(1,ofclzVJAz2530GKhJOB5GXOUj)
(1,accessTokenSecret)
(1,accessToken)
(1,consumerKey)
wordCount: Unit = ()

# Sample about how to use broadcast variables.

import org.apache.spark._
import org.apache.spark.SparkContext._
import org.apache.log4j._
import scala.io.Source
import java.nio.charset.CodingErrorAction
import scala.io.Codec

/** Find the movies with the most ratings. */
object PopularMoviesNicer {
  
  /** Load up a Map of movie IDs to movie names. */
  def loadMovieNames() : Map[Int, String] = {
    
    // Handle character encoding issues:
    implicit val codec = Codec("UTF-8")
    codec.onMalformedInput(CodingErrorAction.REPLACE)
    codec.onUnmappableCharacter(CodingErrorAction.REPLACE)

    // Create a Map of Ints to Strings, and populate it from u.item.
    var movieNames:Map[Int, String] = Map()
    
     val lines = Source.fromFile("../ml-100k/u.item").getLines()
     for (line <- lines) {
       var fields = line.split('|')
       if (fields.length > 1) {
        movieNames += (fields(0).toInt -> fields(1))
       }
     }
    
     return movieNames
  }
 
  /** Our main function where the action happens */
  def main(args: Array[String]) {
   
    // Set the log level to only print errors
    Logger.getLogger("org").setLevel(Level.ERROR)
    
     // Create a SparkContext using every core of the local machine
    val sc = new SparkContext("local[*]", "PopularMoviesNicer")  
    
    // Create a broadcast variable of our ID -> movie name map
    var nameDict = sc.broadcast(loadMovieNames)
    
    // Read in each rating line
    val lines = sc.textFile("../ml-100k/u.data")
    
    // Map to (movieID, 1) tuples
    val movies = lines.map(x => (x.split("\t")(1).toInt, 1))
    
    // Count up all the 1's for each movie
    val movieCounts = movies.reduceByKey( (x, y) => x + y )
    
    // Flip (movieID, count) to (count, movieID)
    val flipped = movieCounts.map( x => (x._2, x._1) )
    
    // Sort
    val sortedMovies = flipped.sortByKey()
    
    // Fold in the movie names from the broadcast variable
    val sortedMoviesWithNames = sortedMovies.map( x  => (nameDict.value(x._2), x._1) )
    
    // Collect and print results
    val results = sortedMoviesWithNames.collect()
    
    results.foreach(println)
  }
  
}


import org.apache.spark.sql.expressions.Window
import org.apache.spark.sql.functions._
import spark.implicits._

    val simpleData = Seq(("James","Sales",3000),
      ("Michael","Sales",4600),
      ("Robert","Sales",4100),
      ("Maria","Finance",3000),
      ("Raman","Finance",3000),
      ("Scott","Finance",3300),
      ("Jen","Finance",3900),
      ("Jeff","Marketing",3000),
      ("Kumar","Marketing",2000)
    )
val df = simpleData.toDF("employee_name","department","salary")
df.show()

//Get the first row from a group.
val w2 = Window.partitionBy("department").orderBy(col("salary"))
df.withColumn("row",row_number.over(w2)).where($"row" === 1).drop("row").show()

//Retrieve Highest salary
val w3 = Window.partitionBy("department").orderBy(col("salary").desc)
df.withColumn("row",row_number.over(w3)).where($"row" === 1).drop("row").show()

//Maximum, Minimum, Average, total salary for each window group
val w4 = Window.partitionBy("department")
val aggDF = df.withColumn("row",row_number.over(w3)).withColumn("avg", avg(col("salary")).over(w4)).withColumn("sum", sum(col("salary")).over(w4)).withColumn("min", min(col("salary")).over(w4)).withColumn("max", max(col("salary")).over(w4)).where(col("row")===1).select("department","avg","sum","min","max").show()

//Retrieve Lowest salary
val w5 = Window.partitionBy("department").orderBy(col("salary").asc)
df.withColumn("row",row_number.over(w5)).where($"row" === 1).drop("row").show()

# Using broadcast...

import org.apache.spark._
import org.apache.spark.SparkContext._
import org.apache.log4j._
import scala.io.Source
import java.nio.charset.CodingErrorAction
import scala.io.Codec
import org.apache.spark.sql.types.{DoubleType, StringType, StructField, StructType}


/** Find the movies with the most ratings. */
object PopularMoviesNicer {
  
  /** Load up a Map of movie IDs to movie names. */
  def loadMovieNames() : Map[Int, String] = {
    
    // Handle character encoding issues:
    implicit val codec = Codec("UTF-8")
    codec.onMalformedInput(CodingErrorAction.REPLACE)
    codec.onUnmappableCharacter(CodingErrorAction.REPLACE)

    // Create a Map of Ints to Strings, and populate it from u.item.
    var movieNames:Map[Int, String] = Map()
    
     val lines = Source.fromFile("../ml-100k/u.item").getLines()
     for (line <- lines) {
       var fields = line.split('|')
       if (fields.length > 1) {
        movieNames += (fields(0).toInt -> fields(1))
       }
     }
    
     return movieNames
  }
 
  /** Our main function where the action happens */
  def main(args: Array[String]) {
   
    // Set the log level to only print errors
    Logger.getLogger("org").setLevel(Level.ERROR)
    
     // Create a SparkContext using every core of the local machine
    val sc = new SparkContext("local[*]", "PopularMoviesNicer")  
    
    // Create a broadcast variable of our ID -> movie name map
    var nameDict = sc.broadcast(loadMovieNames)
    
    // Read in each rating line
    val lines = sc.textFile("../ml-100k/u.data")
    
    // Map to (movieID, 1) tuples
    val movies = lines.map(x => (x.split("\t")(1).toInt, 1))
    
    // Count up all the 1's for each movie
    val movieCounts = movies.reduceByKey( (x, y) => x + y )
    
    // Flip (movieID, count) to (count, movieID)
    val flipped = movieCounts.map( x => (x._2, x._1) )
    
    // Sort
    val sortedMovies = flipped.sortByKey()
    
    // Fold in the movie names from the broadcast variable
    val sortedMoviesWithNames = sortedMovies.map( x  => (nameDict.value(x._2), x._1) )

	// scala> sortedMoviesWithNames
	// res13: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[54] at map at <console>:46
	// i want to save RDD to FS, first thing is to create a Dataframe from it, then i can save it in parquet format.
	val sortedMoviesWithNamesDF = spark.createDataFrame(sortedMoviesWithNames)

	val sortedMoviesWithNamesDFWithSchema = spark.createDataFrame(sortedMoviesWithNames).toDF("name", "count")

	// i can work with one or another, i select first one...
	sortedMoviesWithNamesDF.createTempView("MOVIES")

	spark.sql("SELECT * FROM MOVIES").show(false)

	sortedMoviesWithNamesDF.write.parquet("movies.parquet")


    // Collect and print results
    val results = sortedMoviesWithNames.collect()
    
    results.foreach(println)
  }
  
}

https://sparkbyexamples.com/spark/spark-read-write-dataframe-parquet-example/

https://learning.oreilly.com/videos/apache-spark-with/9781787129849/9781787129849-video4_3?autoplay=false

https://www.arcgis.com/apps/opsdashboard/index.html#/bda7594740fd40299423467b48e9ecf6

https://piotrminkowski.com/2018/05/04/reactive-microservices-with-spring-webflux-and-spring-cloud/

https://dzone.com/articles/5-amazing-examples-of-artificial-intelligence-in-a



