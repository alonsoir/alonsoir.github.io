Mis notas sobre el curso de microservicios de Atomikos.

Si ya es dificil gestionar un monolito, ahora teniendo varios microservicios dedicados a una tarea, es mucho más dificil. Si tenemos 4 tareas distintas gestionadas por un ms instanciado, ahora
imaginad varias instancias de un microservicio, a cuatro instancias levantadas por ms, tenemos 16 instancias corriendo en una nube publica o privada. 

Una manera para acceder a los metodos de cada instancia es englobandolo en un servidor de aplicaciones ligero http rest, sincrono por naturaleza, pues los invocas, el usuario se queda esperando
y el servidor responde con un codigo, que puede ser 20x, 40x, etc...

Esto puede ser problemático, porque como uno se caiga, y solo haya una instancia levantada, el servicio estaría inaccesible e inusable. Uno de los servicios está indispuesto, por lo que una solución sería tener en medio un servicio de mensajeria, un broker de mensajería agnostico, no hablaré de ningun producto aún, si no más bien de publicadores/consumidores alredederor de una cola de mensajería o de un topic.

Con ese servicio en medio de los distintos microservicios, ya podemos pensar en tener alta disponibilidad en el ecosistema de microservicios y asimismo en el servicio de mensajería, pues tiene de por sí
una naturaleza distribuida con alta escalabilidad. De manera natural, como decía antes, ya podemos considerar tener un conjunto de instancias del mismo microservicio para tener alta disponibilidad, pues 
ahora esos ms tendrán un productor para hablar con el servicio de mensajeria y un consumidor para escuchar los mensajes. Si nos damos cuenta, nos podríamos preguntar si no sería necesario tambien un balanceador de carga en el servicio de mensajería para seleccionar a uno y solo un microservicio, pues bien, si implementamos el patron Competing Consumers, podemos saltarnos la necesidad del balanceador de carga en el servicio de mensajería. Literalmente, gracias a la asignación de una cola de mensajes a ese único consumidor, no necesitas un balanceador de carga pues todos los mensajes serán redirigidas a esa instancia del ms.

Uno de los grandes problemas cuando tratamos con sistemas distribuidos y microservicios, bajo mi punto de vista, es la inconsistencia eventual, es decir, imaginemos que tenemos dos servicios distintos, cada uno con su propia base de datos, y que en un momento dado, una de las dos, se destruye, se pierden sus datos, se vuelve inaccesible. Qué hacemos en esa situación? en el mejor de los casos, tiramos de backup para tratar de restaurar los datos, pero muy probablemente aparecerán problemas de inconsistencia cuando este back up tenga que trabajar en consonancia con el otro u otros microservicios, de ahí el nombre de inconsistencia eventual. Este problema aparecerá incluso usando el patrón Saga. Ante ello, podemos hacer dos cosas. 

Una es aceptarlo y tenerlo en cuenta para prepararnos ante ello. Quiero decir que tendremos que pensar en planes de contingencia para reconstruir las bases de datos de manera consistente, hacer backups de cada base de datos cada poco tiempo a la vez, de manera que haya una relacion temporal, solucion que no es perfecta, pero minimizaría el tiempo de vuelta al servicio. 

Otra manera sería que las bases de datos de todos los microservicios estén alojadas en la misma máquina, de manera que cada vez que se haga un backup, se hace el backup de todo a la vez, pero esto ya no sería un verdadero sistema distribuido, pues las bases de datos estarían fuertemente acopladas a los microservicios.

Tiene que haber alguna otra manera de poder solventar el problema de la inconsistencia eventual, que indudablemente aparecerá, pues los sistemas fallan, tarde o temprano, bien sea porque nos quedamos sin cuota de disco, ha habido un incendio, alguien ha ido con una uzi a la oficina, o algo peor.

Me encanta esta definicion, la arquitectura de microservicios es una forma extremadamente eficiente para transformar problemas de negocio en problemas de transaccionalidad distribuida.

Problemas potenciales?

	Inconsistencia eventual, antes he hablado un poco sobre ello.
	La consistencia eventual de los datos, es decir, tratar con datos distribuidos que no son consistentes unos con otros. Cuál es el bueno? el de la instancia A? el de la B?, el de la XYZ? 
	Consumidores idempotentes, AMPLIAR
	EL almacen de eventos, AMPLIAR
	Domain driven design, AMPLIAR
	Patron Saga: 

		Patron que trata de solventar el problema de la consistencia eventual haciendo operaciones de compensacion distribuida, operaciones para rehacer el estado anterior transaccional. No funciona muy bien, pues, puede provocar errores de consistencia cuando ocurra el problema de la inconsistencia eventual.

Vamos a tratar sobre la manera asíncrona para hacer microservicios, es decir, cuando tratamos con bokers de mensajería, ya sea a través de una cola de mensajes o cuando tienes productores y consumidores subscritos a un topic, un buzón. En Java, tenemos implementaciones libres, aquellas basadas en JMS, e implementaciones propietarias, como Kafka.

Basadas en JMS:

	IBM MQ series
	Sonic MQ
	Active MQ
	Fiorano MQ
	Swift MQ
	Tibco MQ

Soportan colas y topics.

JMS basadas en colas. Implica que cada mensaje es entregado a un consumidor, y solo uno. Es escalable de manera natural gracias al patrón Competing Consumer, ya que si necesitamos mayor escalabilidad, solo tenemos que añadir mas consumidores adjuntos a una nueva cola y la carga de mensajería se va a distribuir equitativamente entre los distintos consumidores.

JMS basadas en topics. No es como los topics de kafka. Un Topic en este contexto significa mensajería basada en productores y consumidores. Los mensajes van a todos los consumidores, esta es la principal diferencia con las colas anteriormente descrita. Significa que los mensajes son potencialmente procesables por tantos consumidores haya subscrito al topic. No hay patrón Competing Consumer actuando. Bajo mi punto de vista, hay que evitar este tipo de implementacion para una arquitectura de microservicios pues asignar el mismo mensaje a varios consumidores implica que los microservicios actuaran sobre el mismo mensaje. Interesa que uno y solo uno actue sobre el mensaje, en principio.

Hay dos tipos de subscriptores:
	
	subscripcion duradera: Recibiran mensajes incluso si los productores no estén publicando nuevos mensajes.

	subscripcion no duradera: No recibirán mensajes, los mensajes se perderán si los productores estan publicando nuevos mensajes.

No Basadas en JMS:

	Kafka
	RabbitMQ
	...

Hay varios conceptos importantes a tratar con las manera asíncrona para hacer microservicios, sobre todo porque hay que evitarlos:

	Mensajes perdidos.

	Mensajes fantasma.
	
	Mensajes duplicados.

El mensajero envía potencialmente inconsistencias. 

Basicamente, cuando tratamos con microservicios asíncronos, tenemos dos servicios con los que interactua, uno es la tecnologia de mensajeria, otra es la base de datos en la que guardamos la informacion.

Al tratar con ellas, literalmente el mensaje o la transaccion no está hecha hasta que hacemos commit en ella, bien sea porque el mensaje ha sido finalmente introducido en la cola o el topic para que el consumidor pueda consumirlo, bien porque la bd del ms haga commit. Dependiendo de como tengamos en nuestro codigo el orden de la ejecucion transaccional, podremos tener potencialmente un error u otro cuando ocurra algún problema. Esos problemas pueden ser por ejemplo que el contenedor que contiene el ms se cae, bien porque k8s ha tenido algún problema, porque la cuota de disco en la bd se haya cumplido, porque alguien haya pegado fuego al cluster de datos, o también puede ser pq los nodos de mensajería se hayan caído tambien, por lo que tambien sería imposible hacer commit en la cola de mensajería.

Ojo, estoy hablando de la fase en la que ya hemos invocado al microservicio via REST, es decir, está preparado para invocar a la bd para hacer el commit y a pushear el mensaje para decirle a quien quiera que esté escuchando un mensaje diciendo lo que sea. 

Aquí tenemos un gran desafío, enviar un mensaje si y solo si, primero queremos hacer commit en la bd, es decir, vamos a hacer un insert, update o delete, operaciones que si o si necesitan de un commit en la bd, en ese caso debemos ser capaces de hacer commit en ambos sistemas, porque si solo hacemos commit en uno de los sistemas, dependiendo del orden en el que hayamos ejecutado la orden del commit, tendremos un problema u otro. El problema especialmente es que hay que hacer commit en ambos sistemas, pues, para que el mensaje sea visible en la cola para los consumidores, el sistema de mensajería debe hacer commit, y de igual manera para la bd, hay que hacer commit en la operacion de insercion, borrado o actualización.

Basicamente, poner en el mismo método transaccional invocaciones a ambos sistemas, no va a funcionar, pues potencialmente uno de los dos sistemas, o los dos, no van a funcionar. 

Tendremos mensajes perdidos si primero hacemos commit en la bd y luego no somos capaces de hacer commit en la cola de mensajería, en el broker. Esos problemas con el broker pueden ser variados, como que te quedes sin memoria, el típico OutOfMemoryException, puede ser un bug en la libreria del broker, que alguien mate el contenedor del microservicio o del broker, incluso puede ocurrir cuando se ha detectado algún error de esos y el sistema está haciendo un RESTART de esa parte del sistema. 

	@Transactional 
	public void save() {
		jdbcTemplate.execute("INSERT INTO Order VALUES()"); // esto se ejecuta bien, commit en la bd.
		jmsTemplate.convertAndSend("Order created..."); // aqui salta una excepcion, no hacemos commit en la cola, por lo que el consumidor no se entera del commit en la bd. Tendremos un mensaje perdido.
	}

Tendremos mensajes fantasmas si primero hacemos commit en el broker de mensajería diciendo que hemos hecho commit en la bd, y luego al invocar la logica del commit en la bd tenemos un crash. Es decir, si tenemos algo así:

	@Transactional 
	public void save() {
		jmsTemplate.convertAndSend("Order created..."); // esto se ejecuta bien, commit en el broker
		jdbcTemplate.execute("INSERT INTO Order VALUES()"); // aqui salta una excepcion, no hacemos commit en la bd. Tendremos un mensaje fantasma.

	}

Si en el caso del mensaje fantasma, en el que no hemos sido capaces de hacer commit en la base de datos, potencialmente hablando publicaremos de nuevo en la cola de mensajes, es decir, haremos commit en el broker de mensajería teniendo un mensaje duplicado. Basicamente, tratar que nuestras transacciones sigan un orden es dificil y potencialmente fallable, pues entre medias puede ocurrir el desastre, da igual que lo llames problema de mensaje perdido, mensaje fantasma o mensaje duplicado. Son errores que tendremos que tener en cuenta en nuestra arquitectura para solventarlos.

Conclusión

Probablementente es una mala idea tener en Los metodos transaccionales de acceso a bases de datos invocaciones al broker de mensajería.

El mensajero recibe inconsistencias. Ver de nuevo, porque parece que está describiendo los mismos problemas anteriormente expuestos. En funcion de si encontramos algun problema entre hacer commit en la cola primero y hacer commit en la bd despues, problemas. Si invertimos el orden igual. Es un problema gordo.

Enviando mensajes sin inconsistencias.

Cuando hablamos de este tema, hablamos del problema de enviar el mensaje a la cola, hacer un commit en la cola de mensajes, si y solo si, podemos hacer un commit en la bd del microservicio. Para ello, tenemos dos posibilidades, una es seguir el protocolo Saga, que nos proporciona la capacidad de poder hacer transacciones compensatorias, la otra es seguir el protocolo Two commit phase, que necesita de la figura de un Servicio que gestione la transaccionalidad distribuida. Es decir, un servicio que pregunte a los distintos componentes si estan en disposicion de hacer el commit en sus distintas bases de datos y en las colas de mensajes. Es como decirles, "eh!, estais preparados para hacer todo lo necesario para guardar los datos e indicar a los otros que podemos hacer nuestro trabajo?", esto dicho con mi tono de voz de alguien de Extremadura suena más gracioso...

El uso de estas tecnicas es para que podamos superar el hecho de que es un error poner en el metodo transaccional las dos llamadas, tanto al SGBD como a la cola de mensajes. Da igual en el orden en el que las pongamos, potencialmente hablando, puede haber en un fallo en cualquiera de los dos sistemas. 

El verdadero problema cuando tratamos con estos sistemas distribuidos es:

	Enviar un commit a una bd no garantiza que dicho sistema lo vaya a hacer, porque:

		si hay un timeout intermedio en la base de datos, ocurrirá un rollback automático,

		Si hay un fallo físico en la bd antes que el commit llegue, tendremos que forzar nosotros el rollback, o el mismo SGBD automáticamente hará el rollback. Lo más probable es que sea esto último.

	Lo mismo ocurre a nivel de la cola de mensajes, esos fallos físicos, cuando ocurran, conllevarán a inconsistencias.
	Como consecuencia de estos problemas potenciales, preguntar a varios sistemas distribuidos para hacer commit SIEMPRE es una situacion de riesgo, porque, bien uno hacerlo, el otro no, los dos no pueden,
	lo que inevitablemente conllevará, bien a situaciones de inconsistencias en el mejor de los casos en el que uno de los sistemas no pueda hacer commit, o a situaciones de bloqueo pq ambos sistemas no pueden hacer commit. Es así. En el primer caso, los protocolos TPC y Sagas, tratan de compensar lo mejor posible dichas transacciones distribuidas que se han quedado en el aire. En el segundo, sólo podemos vigilar muy bien el sistema para tratar de no llegar nunca a esa situación y adelantarnos antes de que vaya a ocurrir. Dichos problemas de bloqueo pueden venir desde multiples lugares, como problemas en la cuota de disco, mal estado en los discos, problemas en la red, problemas gestionando el cluster, etc...

Ahora, el desafío es tratar a dichas transacciones distribuidas como una transaccion global, es decir combinar ambos commits, el de la bd y el de la cola en una sola. Asegurar que se pueden hacer ambos commits en cada una de las fases. 

Ojo, entiendo que la transaccion distribuida es el conjunto de la transaccion en la bd y la transaccion en la cola de eventos en un solo microservicio. No estoy hablando de todas las transacciones necesarias para una operacion compleja como ordenar una peticion de compra por parte de un usuario. Dichas peticiones, normalmente sería algo como comprobar que el usuario está en el sistema, el usuario busca un producto para comprar, el usuario solicita comprar el producto, el sistema comprueba si el usuario tiene todo en regla para poder comprar, el sistema solicita si el producto está en stock, el sistema hace el cargo del producto en su cuenta, el sistema devuelve el estado de dicha operacion inicial. Cada una de esas operaciones, conlleva una transacción global. Intimidado?

En principio, puede hacerse, aunque es complejo, muy complejo. Voy a hablar un poco sobre como se haría con el protocolo Two Commit Phase. El truco se puede llamar Estado intermedio preparado, Intermediate prepared state. Los puntos claves ante esta estrategia son:

	Un Backend que está advertido, puede hacer rollback, nos hemos asegurado de ello, pero no debe hacerlo por su cuenta, por iniciativa propia, porque no querremos en principio ni rollbacks cuando el sistema potencialmente se reinicie, ni rollbacks si ocurren timeouts internos en la bd.

	Un backend que está preparado puede hacer commit, incluso si ha habido un problema grande en la bd.

	Podemos ver al "estado preparado", como un checkpoint desde el cual tenemos seguridad de poder hacer commit o rollback a la vez en ambos sistemas o en uno solo. El caso es que necesitamos control preciso sobre estos dos sistemas.

	Este checkpoint es gestionado y controlado por un manejador de transacciones.

	Para un sistema así, necesitamos tecnologia JMS con soporte XA, tecnologia de bd con soporte XA, y un gestor de transacciones que gestione a esos dos sistemas anteriores. 

Practicamente todos los sistemas de colas y de bd soportan XA, extendend architecture, por lo que, la parte principal del problema es implementar un buen manejador de transacciones distribuidas.
Básicamente, lo que debe hacer dicho manejador es:

	Preparar SGBD

		Si responde KO, rollback en ambos sistemas, el sgbd y el broker.
		Si responde OK, pasamos a la siguiente fase.

	Preparar broker
		Si responde KO, rollback en ambos sistemas, el sgbd y el broker.
		Si responde OK, implica que ambos han dicho ok.

	si ambos responden OK, se escribe al log que todo ha ido bien y se hace commit en los dos. Es importante el orden aquí. 
	Es decir, ahora si podemos hacer lo que poniamos en el método marcado como transaccional, escribir en el log que todo ha ido bien, hacer commit en el broker con un mensaje exitoso, hacer commit en la bd.

	Pregunta incomoda, que pasa si después de haber pasado por los dos primeros puntos, en el que tenemos el ok de los dos sistemas, ocurre una catastrofe que impide realmente hacer commit o rollback?

Un usuario en Stackoverflow opina así:

	"In my understanding (not a big user of 2PC since I consider it limiting):

	Typically, 2PC is for immediate transactions.
	Typically, Sagas are for long running transactions.
	Use cases are obvious afterwards:

	2PC can allow you to commit the whole transaction in a request or so, spanning this request across systems and networks. Assuming each participating system and network follows the protocol, you can commit or rollback the entire transaction seamlessly.
	Saga allows you split transaction into multiple steps, spanning long periods of times (not necessarily systems and networks).
	Example:

	2PC: Save Customer for every received Invoice request, while both are managed by 2 different systems.
	Sagas: Book a flight itinerary consisting of several connecting flights, while each individual flight is operated by different airlines.
	I personally consider Saga capable of doing what 2PC can do. Opposite is not accurate.

	I think Sagas are universal, while 2PC involves platform/vendor lockdown."


Links

Competing consumer pattern
	
	https://atomikos.teachable.com/courses/475866/lectures/9340469

	https://www.google.com/search?client=safari&rls=en&q=competing+consumer+pattern&ie=UTF-8&oe=UTF-8 

	https://blog.cdemi.io/design-patterns-competing-consumer-pattern/

	https://github.com/ddd-by-examples/all-things-cqrs

Two phased commits

	https://es.wikipedia.org/wiki/Commit_de_dos_fases

	https://stackoverflow.com/questions/48906817/2pc-vs-sagas-distributed-transactions

	https://www.atomikos.com/Documentation/SagasVsTwoPhaseCommitVsTCC

	https://dzone.com/articles/xa-transactions-2-phase-commit

	https://en.wikipedia.org/wiki/X/Open_XA

JTA/XA

	https://en.wikipedia.org/wiki/Java_Transaction_API

	https://www.atomikos.com/Documentation/WhenToUseJtaXa

	https://www.infoworld.com/article/2077714/xa-transactions-using-spring.html

	https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-jta.html

Microlitos, microservicios y monolitos.

	https://www.paradigmadigital.com/techbiz/microservicios-vs-microlitos-vs-monolitos-ventajas-desventajas/


